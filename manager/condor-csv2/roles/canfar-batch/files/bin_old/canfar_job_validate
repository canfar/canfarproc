#!/usr/bin/env python
#
# A user provides a bare condor job description file, as well as image
# and flavor IDs.
#
# This script validates these inputs and writes an augmented condor
# job file including extra cloud scheduler parameters to stdout (or a
# specified output file), and also generates a cloud-config script
# that cloud scheduler will use to configure running instances of the
# VM to work with Condor.
#
# Bad exit status is set upon failure.

import argparse
import errno

import keystoneclient.exceptions
import keystoneauth1.session as kssession
import keystoneauth1.identity.v3 as ksv3

import glanceclient.client as glclient
from glanceclient.exc import HTTPConflict


import os
import re
import requests
import sys
import uuid
import logging
import warnings
#logging.basicConfig()
logging.disable(logging.CRITICAL)

# Parameters that we generate (e.g., from command-line parameters)
# and don't want user to define, along with a message explaining why.
param_disallow = dict(
    [ ['Requirements', 'Generated from image'],
      ['+VMAMI', 'Generated from image'],
      ['+VMInstanceType', 'Generated from flavor']
    ] )

param_preset = dict(
    [ ['Universe', 'vanilla'],
      ['when_to_transfer_output', 'ON_EXIT_OR_EVICT'],
      ['transfer_output_files', '/dev/null'],
      ['should_transfer_files', 'YES'],
      ['RunAsOwner', 'True'],
      ['+PreCmd', '"canfar_batch_cert"'],
      ['+VMKeepAlive', '3']
     ] )

# OpenStack auth configuration / defaults.
# Take OS_* variables if provided (with following defaults).
# command-line overrides OS_*
if 'OS_AUTH_URL' not in os.environ:
    os.environ['OS_AUTH_URL'] = 'https://west.cloud.computecanada.ca:5000/v2.0'
if 'OS_USERNAME' not in os.environ and 'USER' in os.environ:
    os.environ['OS_USERNAME'] = os.environ['USER']

auth = {'username':'',
        'password':'',
        'project_name' : '',
        'project_id' : '',
        'auth_url':''}

# where to find some common inputs
prefix = '/usr/local'
sharepath = prefix + '/share/canfar'
canfaropspubkey = sharepath + '/canfarops_rsa.pub'
confscript = sharepath + '/canfar_batch_init'
certscript = sharepath + '/canfar_batch_cert'

# Location for per-user cloud config YAML files. The actual file name
# is a uuid to avoid clashes (since these are user- and job-specific)
confdir = '/var/cache/canfar/cloudinit'

# Subroutine to generate a cloud config file. This is copied almost verbatim
# from make_cloud_config, and should be moved to a module at a later point.
def make_cloud_config(conf_script, pubkey, output_yml, cert_script,
                      job_submitter, image_name, central_manager_ip):
    # Generate a cloud config file (YAML) that performs the following
    # operations:
    # - inject a public ssh key into the generic user account
    # - write and execute the cloud scheduler configuration script
    # - image_name and image_user are used by canfar_batch_init to
    #   set the VMType. If not specified defaults to $HOSTNAME and $USER

    # the full output path name of the configuration script when copied
    # into the VM
    conf_script_path ='/usr/bin/' + os.path.basename(conf_script)
    cert_script_path ='/usr/bin/' + os.path.basename(cert_script)

    # load script content
    conf_script_content_raw = open(conf_script,'r').readlines()
    conf_script_content = "".join("      "+l for l in conf_script_content_raw)

    # load cert script content
    cert_script_content_raw = open(cert_script,'r').readlines()
    cert_script_content = "".join("      "+l for l in cert_script_content_raw)

    # load canfarops pubkey
    pubkey_content = open(pubkey,'r').read().strip()

    conf_script_args = ", '--user=%s', '--image-name=\"%s\"', '--central-manager-ip=%s'" % (job_submitter, image_name, central_manager_ip)

    start_text = '''#cloud-config
# DO NOT EDIT THIS FILE: generated by canfar_job_validate

ssh_authorized_keys:
  - %s

runcmd:
  - |
      cat - > %s <<'END_OF_SCRIPT'
''' % (pubkey_content, conf_script_path)

    mid_text = '''
      END_OF_SCRIPT
  - [ 'chmod', '0755', '%s' ]
  - [ '%s'%s ]
  - |
      cat - > %s <<'END_OF_SCRIPT'
''' % (conf_script_path, conf_script_path, conf_script_args, cert_script_path)

    end_text = '''
      END_OF_SCRIPT
  - [ 'chmod', '0755', '%s' ]
''' % (cert_script_path)

    f = open(output_yml,'w')
    f.write(start_text)
    f.write(conf_script_content)
    f.write(mid_text)
    f.write(cert_script_content)
    f.write(end_text)
    f.close()


# --- ENTRYPOINT --------------------------------------------------------------

try:
    # Parse command line
    description = \
    '''Create a validated CANFAR submission file (written to stdout, unless
    '--outfile' specified), and a customized cloud-config YAML file (in %s),
    based on a Condor job description file, job execution script, image, and
    flavor.
    ''' % confdir
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('jobfile',help='Condor job description file')
    parser.add_argument('jobscript',help='Condor job execution script')
    parser.add_argument('image_id',help='VM image ID for job')
    parser.add_argument('flavor_id',help='hardware flavor ID')
    
    parser.add_argument('--cert',help='cadc proxy cert path')
    parser.add_argument('--cmip',help='central manager ip (default submission host)')
    parser.add_argument('--outfile',help='write new jobfile instead of printing to stdout')
    parser.add_argument('--submitter',help='Set user to execute the jobs on VM workers (default: automatically detect)')
    parser.add_argument('-v','--verbose',default=False, help='verbose output',action='store_true')

    args = parser.parse_args()

    if args.submitter:
        submitter = args.submitter
    else:
        try:
            submitter = os.environ['USER']
        except:
            raise Exception('Error obtaining submitter name from current user')

    conf_yml = '%s/%s_%s.yml' % (confdir, submitter, uuid.uuid4())

    if args.cert:
        certpath = args.cert
    else:
        certpath = os.path.join(os.environ['HOME'],'.ssl','cadcproxy.pem')

    if args.cmip:
        cmip = args.cmip
    else:
        cmip = "206.12.90.226"
        
    if not os.path.isfile(certpath):
        warnings.warn("Could not find a certificate at %s for VOSpace access" % certpath)
        certarg = ""
    else:
        certarg = os.path.basename(certpath)

    jobfile = args.jobfile
    jobscript = args.jobscript

    # check for valid UUIDs
    try:
        image_id = str(uuid.UUID(args.image_id))
    except:
        raise Exception("image_id '%s' is not a valid UUID" % args.image_id)
    try:
        flavor_id = str(uuid.UUID(args.flavor_id))
    except:
        raise Exception("flavor_id '%s' is not a valid UUID" % args.flavor_id)


    # Check parameters in jobfile
    try:
        if args.verbose:
            print "Loading jobfile."
        jobfile_data = open(jobfile,'r').read()
    except:
        raise Exception("Could not read the contents of "+jobfile)

    if args.verbose:
        print "Searching for illegal keywords in job file"
    for param in param_disallow:
        par_regex = param
        if param[0] == '+':
            # Parameters that start with + need to be escaped in regex
            par_regex = '\\'+par_regex
        regex = "^\s*"+par_regex+"\s*=.*$"
        found = re.search(regex,jobfile_data,re.MULTILINE)

        if found:
            msg = "jobfile should not contain parameter '%s'. Reason: %s" \
                  % (param, param_disallow[param])
            raise Exception(msg)

    if args.verbose:
        print "Presetting keywords in job file if necessary"
    for param in param_preset:
        par_regex = param
        if param[0] == '+':
            # Parameters that start with + need to be escaped in regex
            par_regex = '\\'+par_regex
        regex = "^\s*"+par_regex+"\s*=.*$"
        found = re.search(regex, jobfile_data, re.MULTILINE)
        if not found:
            jobfile_data = "%s = %s\n" % (param, param_preset[param]) + jobfile_data

    # Re-write 'Executable' line since the proc web service will have
    # placed it somewhere different from the user's original location
    if args.verbose:
        print "Updating Executable to '%s'." % jobscript
    if not os.path.isfile(jobscript):
        raise Exception("jobscript '%s' does not exist" % jobscript)

    jobfile_data =  re.sub('^\s*Executable\s*=\s*(.*)$',
                           'Executable = %s' % jobscript,
                           jobfile_data,flags=re.MULTILINE)

    # if os.path.isfile(certpath):
    #     jobfile_data,c =  re.subn('^\s*transfer_input_files\s*=(.*)',
    #                               r'transfer_input_files = \1, %s, %s' % (certscript, certpath),
    #                               jobfile_data, flags=re.MULTILINE)
    #     if (c == 0):
    #         jobfile_data = 'transfer_input_files = %s, %s\n' % (certscript, certpath) + jobfile_data
    # else:
    #     jobfile_data,c =  re.subn('^\s*transfer_input_files\s*=(.*)',
    #                               r'transfer_input_files = \1, %s' % (certscript),
    #                               jobfile_data, flags=re.MULTILINE)
    #     if (c == 0):
    #         jobfile_data = 'transfer_input_files = %s\n' % (certscript) + jobfile_data

    # using x509userproxy below method seems to work so far (i.e. no need of being actually part of the grid)
    # uncomment above if any issues.
    if os.path.isfile(certpath):
        jobfile_data = 'x509userproxy = %s\n' % (certpath) + jobfile_data
        
    jobfile_data,c =  re.subn('^\s*transfer_input_files\s*=(.*)',
                              r'transfer_input_files = \1, %s' % (certscript),
                              jobfile_data, flags=re.MULTILINE)
    if (c == 0):
        jobfile_data = 'transfer_input_files = %s\n' % (certscript) + jobfile_data
        

    # determine the name of the image from its UUID, and the name
    # of the project that owns it. First we get a glance client to
    # get the name of the given image ID. We then query that image's
    # metadata to obtain its owner project id. Finally, we use a second
    # keystone client scoped to the image's owner project to obtain
    # its project name
    if args.verbose:
        print "Determine image name and project id"

    auth = ksv3.Password(auth_url=os.environ['OS_AUTH_URL'],
                         username=os.environ['OS_USERNAME'],
                         password=os.environ['OS_PASSWORD'],
                         project_id=os.environ['OS_PROJECT_ID'],
                         user_domain_name=os.environ['OS_USER_DOMAIN_NAME'])
    
    sess = kssession.Session(auth=auth)
    g = glclient.Client('2', session=sess)
    i = g.images.get(image_id)
    image_name = i['name']
    project_name = os.environ['OS_PROJECT_NAME']

    # generate cloud config file for this user
    try:
        # Make the directory for the file if not already there
        os.makedirs(confdir)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(confdir):
            pass
    else:
        raise

    vmtype = '%s:%s' % (project_name, image_name)

    if args.verbose:
        print("Generating cloud config script (YAML) with:")
        print("canfarops pubkey     = %s" % canfaropspubkey)
        print("config shell script = %s" % confscript)
        print("image_name          = %s" % image_name)
        print("project_name   = %s" % project_name)
        print("submitter           = %s" % submitter)
        print("vmtype           = %s" % vmtype)
        print("cmip           = %s" % cmip)
        print("output YAML         = %s" % conf_yml)

    make_cloud_config(confscript,
                      canfaropspubkey,
                      conf_yml,
                      certscript,
                      submitter,
                      vmtype,
                      cmip)

except Exception as E:
    print "ERROR:",E
    if isinstance(E, keystoneclient.exceptions.Unauthorized):
        print "Did you source a valid openrc file? (i.e., are OS_* environment variables set?)\n" + \
            "Check for errors in your credentials."
    sys.exit(1)


jobfile = '''
Requirements = VMType =?= "%s" && Arch == "x86_64"
+VMAMI          = "cc-arbutus:%s"
+VMInstanceType = "cc-arbutus:%s"
+VMAMIConfig    = "%s"
+PreArguments   = "%s"

''' % (vmtype, image_id, flavor_id, conf_yml, certarg) + jobfile_data

if args.outfile:
    try:
        open(args.outfile,'w').write(jobfile)
        print "Modified jobfile written to --outfile '%s'" % args.outfile
    except Exception as E:
        print "ERROR: Failed to write --outfile '%s'" % args.outfile
        print E
        sys.exit(1)
else:
    if args.verbose:
        print "---BEGIN JOBFILE---------------------------------------------------------------"
    print jobfile

sys.exit(0)
